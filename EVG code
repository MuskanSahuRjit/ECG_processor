module fir_sym_file#(
  parameter integer TAPS = 61,
  parameter integer COEFF_WIDTH = 16,
  parameter integer DATA_WIDTH = 16,
  parameter integer ACC_WIDTH  = 48
)(
input  wireclk,
input  wirerstn,
input  wirevalid_in,
input  wire signed [DATA_WIDTH-1:0]  din,
  output reg  signed [DATA_WIDTH-1:0]  dout,
  output reg                        valid_out
);
  // shift register
  reg signed [DATA_WIDTH-1:0] shift_reg [0:TAPS-1];
  integer i;
  always @(posedgeclk) begin
    if (!rstn) begin
      for (i=0;i<TAPS;i=i+1) shift_reg[i] <= 0;
    end else if (valid_in) begin
      for (i=TAPS-1;i>0;i=i-1) shift_reg[i] <= shift_reg[i-1];
shift_reg[0] <= din;
    end
  end

  // coefficients (full set loaded from mem)
  reg signed [COEFF_WIDTH-1:0] coeffs [0:TAPS-1];
initial begin
    $readmemh("hp_coeffs.hex", coeffs);
End
localparam integer HALF = (TAPS+1)/2;
  reg signed [ACC_WIDTH-1:0] acc;
  reg signed [DATA_WIDTH+COEFF_WIDTH+8:0] tmp; // helper
  always @(posedgeclk) begin
    if (!rstn) begin
      acc <= 0;
dout<= 0;
valid_out<= 0;
    end else if (valid_in) begin
      acc <= 0;
      for (i=0;i<HALF;i=i+1) begin
        // sum mirrored samples (they fit in DATA_WIDTH+1 bits after addition)
tmp = $signed(shift_reg[i]) + $signed(shift_reg[TAPS-1-i]);
        // multiply coeff[i] * tmp (promote to larger signed width)
        acc <= acc + ($signed(coeffs[i]) * $signed(tmp));
      end
      // acc has extra Q fractional bits (coeff Q1.15), so shift right by 15
dout<= $signed(acc >>> 15);
valid_out<= 1;
    end else begin
valid_out<= 0;
    end
  end

endmodule
